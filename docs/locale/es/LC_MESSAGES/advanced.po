# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Reinier Hernández
# This file is distributed under the same license as the CryptoBot Python
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: CryptoBot Python 0.1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-18 10:28-0300\n"
"PO-Revision-Date: 2025-11-18 10:30-0300\n"
"Last-Translator: Claude <noreply@anthropic.com>\n"
"Language: es\n"
"Language-Team: es <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../advanced.md:1
msgid "Advanced Topics"
msgstr "Temas Avanzados"

#: ../../advanced.md:3
msgid ""
"This guide covers advanced patterns, optimizations, and best practices "
"for production deployments."
msgstr ""
"Esta guía cubre patrones avanzados, optimizaciones y mejores prácticas "
"para despliegues en producción."

#: ../../advanced.md:5
msgid "Connection Management"
msgstr "Gestión de Conexiones"

#: ../../advanced.md:7
msgid "Custom HTTP Client Configuration"
msgstr "Configuración Personalizada del Cliente HTTP"

#: ../../advanced.md:9
msgid "Configure the underlying httpx client for production use:"
msgstr "Configure el cliente httpx subyacente para uso en producción:"

#: ../../advanced.md:11
#, python-brace-format
msgid ""
"import httpx\n"
"from cryptobot import CryptoBotClient\n"
"\n"
"# Create a custom client with connection pooling\n"
"class ProductionCryptoBotClient(CryptoBotClient):\n"
"    def __init__(self, api_token, is_mainnet=True, timeout=30.0, "
"max_connections=100):\n"
"        super().__init__(api_token, is_mainnet, timeout)\n"
"\n"
"        # Override the HTTP client with custom settings\n"
"        self._CryptoBotClient__http_client = httpx.Client(\n"
"            base_url=self._CryptoBotClient__base_url,\n"
"            timeout=timeout,\n"
"            headers={\"Crypto-Pay-API-Token\": self.api_token},\n"
"            limits=httpx.Limits(\n"
"                max_keepalive_connections=max_connections,\n"
"                max_connections=max_connections,\n"
"                keepalive_expiry=30.0\n"
"            )\n"
"        )\n"
"\n"
"# Usage\n"
"client = ProductionCryptoBotClient(\n"
"    \"YOUR_API_TOKEN\",\n"
"    timeout=60.0,\n"
"    max_connections=50\n"
")\n"
msgstr ""
"import httpx\n"
"from cryptobot import CryptoBotClient\n"
"\n"
"# Create a custom client with connection pooling\n"
"class ProductionCryptoBotClient(CryptoBotClient):\n"
"    def __init__(self, api_token, is_mainnet=True, timeout=30.0, "
"max_connections=100):\n"
"        super().__init__(api_token, is_mainnet, timeout)\n"
"\n"
"        # Override the HTTP client with custom settings\n"
"        self._CryptoBotClient__http_client = httpx.Client(\n"
"            base_url=self._CryptoBotClient__base_url,\n"
"            timeout=timeout,\n"
"            headers={\"Crypto-Pay-API-Token\": self.api_token},\n"
"            limits=httpx.Limits(\n"
"                max_keepalive_connections=max_connections,\n"
"                max_connections=max_connections,\n"
"                keepalive_expiry=30.0\n"
"            )\n"
"        )\n"
"\n"
"# Usage\n"
"client = ProductionCryptoBotClient(\n"
"    \"YOUR_API_TOKEN\",\n"
"    timeout=60.0,\n"
"    max_connections=50\n"
")\n"

#: ../../advanced.md:40
msgid "Retry Logic with Exponential Backoff"
msgstr "Lógica de Reintentos con Retroceso Exponencial"

#: ../../advanced.md:42
msgid "Implement robust retry logic for transient failures:"
msgstr "Implemente lógica de reintentos robusta para fallos transitorios:"

#: ../../advanced.md:44
msgid ""
"import time\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.errors import CryptoBotError\n"
"\n"
"class ResilientClient:\n"
"    def __init__(self, api_token, max_retries=3):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.max_retries = max_retries\n"
"\n"
"    def _retry_with_backoff(self, func, *args, **kwargs):\n"
"        \"\"\"Execute function with exponential backoff retry\"\"\"\n"
"        for attempt in range(self.max_retries):\n"
"            try:\n"
"                return func(*args, **kwargs)\n"
"            except CryptoBotError as e:\n"
"                # Only retry on server errors (5xx) or rate limits\n"
"                if e.code >= 500 or e.code == 429:\n"
"                    if attempt < self.max_retries - 1:\n"
"                        wait_time = (2 ** attempt) + (0.1 * attempt)\n"
"                        time.sleep(wait_time)\n"
"                        continue\n"
"                raise\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Create invoice with retry logic\"\"\"\n"
"        return self._retry_with_backoff(\n"
"            self.client.create_invoice,\n"
"            **kwargs\n"
"        )\n"
"\n"
"    def transfer(self, **kwargs):\n"
"        \"\"\"Transfer with retry logic\"\"\"\n"
"        return self._retry_with_backoff(\n"
"            self.client.transfer,\n"
"            **kwargs\n"
"        )\n"
"\n"
"# Usage\n"
"resilient_client = ResilientClient(\"YOUR_API_TOKEN\", max_retries=3)\n"
"invoice = resilient_client.create_invoice(\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Resilient invoice\"\n"
")\n"
msgstr ""
"import time\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.errors import CryptoBotError\n"
"\n"
"class ResilientClient:\n"
"    def __init__(self, api_token, max_retries=3):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.max_retries = max_retries\n"
"\n"
"    def _retry_with_backoff(self, func, *args, **kwargs):\n"
"        \"\"\"Execute function with exponential backoff retry\"\"\"\n"
"        for attempt in range(self.max_retries):\n"
"            try:\n"
"                return func(*args, **kwargs)\n"
"            except CryptoBotError as e:\n"
"                # Only retry on server errors (5xx) or rate limits\n"
"                if e.code >= 500 or e.code == 429:\n"
"                    if attempt < self.max_retries - 1:\n"
"                        wait_time = (2 ** attempt) + (0.1 * attempt)\n"
"                        time.sleep(wait_time)\n"
"                        continue\n"
"                raise\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Create invoice with retry logic\"\"\"\n"
"        return self._retry_with_backoff(\n"
"            self.client.create_invoice,\n"
"            **kwargs\n"
"        )\n"
"\n"
"    def transfer(self, **kwargs):\n"
"        \"\"\"Transfer with retry logic\"\"\"\n"
"        return self._retry_with_backoff(\n"
"            self.client.transfer,\n"
"            **kwargs\n"
"        )\n"
"\n"
"# Usage\n"
"resilient_client = ResilientClient(\"YOUR_API_TOKEN\", max_retries=3)\n"
"invoice = resilient_client.create_invoice(\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Resilient invoice\"\n"
")\n"

#: ../../advanced.md:91
msgid "Rate Limiting"
msgstr "Limitación de Tasa"

#: ../../advanced.md:93
msgid "Token Bucket Rate Limiter"
msgstr "Limitador de Tasa por Cubo de Tokens"

#: ../../advanced.md:95
msgid "Implement rate limiting to avoid API throttling:"
msgstr "Implemente limitación de tasa para evitar la restricción de la API:"

#: ../../advanced.md:97
#, python-brace-format
msgid ""
"import time\n"
"import threading\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset\n"
"\n"
"class RateLimitedClient:\n"
"    def __init__(self, api_token, requests_per_second=10):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.requests_per_second = requests_per_second\n"
"        self.tokens = requests_per_second\n"
"        self.max_tokens = requests_per_second\n"
"        self.last_update = time.time()\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def _acquire_token(self):\n"
"        \"\"\"Acquire a token using token bucket algorithm\"\"\"\n"
"        with self.lock:\n"
"            now = time.time()\n"
"            elapsed = now - self.last_update\n"
"\n"
"            # Add tokens based on elapsed time\n"
"            self.tokens = min(\n"
"                self.max_tokens,\n"
"                self.tokens + elapsed * self.requests_per_second\n"
"            )\n"
"            self.last_update = now\n"
"\n"
"            if self.tokens < 1:\n"
"                # Wait until we have a token\n"
"                wait_time = (1 - self.tokens) / self.requests_per_second\n"
"                time.sleep(wait_time)\n"
"                self.tokens = 0\n"
"            else:\n"
"                self.tokens -= 1\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Rate-limited invoice creation\"\"\"\n"
"        self._acquire_token()\n"
"        return self.client.create_invoice(**kwargs)\n"
"\n"
"    def get_invoices(self, **kwargs):\n"
"        \"\"\"Rate-limited invoice retrieval\"\"\"\n"
"        self._acquire_token()\n"
"        return self.client.get_invoices(**kwargs)\n"
"\n"
"# Usage\n"
"rate_limited_client = RateLimitedClient(\"YOUR_API_TOKEN\", "
"requests_per_second=5)\n"
"\n"
"# Make multiple requests without overwhelming the API\n"
"for i in range(20):\n"
"    invoice = rate_limited_client.create_invoice(\n"
"        asset=Asset.USDT,\n"
"        amount=1.0,\n"
"        description=f\"Invoice {i}\"\n"
"    )\n"
"    print(f\"Created invoice {i}: {invoice.invoice_id}\")\n"
msgstr ""
"import time\n"
"import threading\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset\n"
"\n"
"class RateLimitedClient:\n"
"    def __init__(self, api_token, requests_per_second=10):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.requests_per_second = requests_per_second\n"
"        self.tokens = requests_per_second\n"
"        self.max_tokens = requests_per_second\n"
"        self.last_update = time.time()\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def _acquire_token(self):\n"
"        \"\"\"Acquire a token using token bucket algorithm\"\"\"\n"
"        with self.lock:\n"
"            now = time.time()\n"
"            elapsed = now - self.last_update\n"
"\n"
"            # Add tokens based on elapsed time\n"
"            self.tokens = min(\n"
"                self.max_tokens,\n"
"                self.tokens + elapsed * self.requests_per_second\n"
"            )\n"
"            self.last_update = now\n"
"\n"
"            if self.tokens < 1:\n"
"                # Wait until we have a token\n"
"                wait_time = (1 - self.tokens) / self.requests_per_second\n"
"                time.sleep(wait_time)\n"
"                self.tokens = 0\n"
"            else:\n"
"                self.tokens -= 1\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Rate-limited invoice creation\"\"\"\n"
"        self._acquire_token()\n"
"        return self.client.create_invoice(**kwargs)\n"
"\n"
"    def get_invoices(self, **kwargs):\n"
"        \"\"\"Rate-limited invoice retrieval\"\"\"\n"
"        self._acquire_token()\n"
"        return self.client.get_invoices(**kwargs)\n"
"\n"
"# Usage\n"
"rate_limited_client = RateLimitedClient(\"YOUR_API_TOKEN\", "
"requests_per_second=5)\n"
"\n"
"# Make multiple requests without overwhelming the API\n"
"for i in range(20):\n"
"    invoice = rate_limited_client.create_invoice(\n"
"        asset=Asset.USDT,\n"
"        amount=1.0,\n"
"        description=f\"Invoice {i}\"\n"
"    )\n"
"    print(f\"Created invoice {i}: {invoice.invoice_id}\")\n"

#: ../../advanced.md:156
msgid "Caching Strategies"
msgstr "Estrategias de Caché"

#: ../../advanced.md:158
msgid "Exchange Rate Caching"
msgstr "Caché de Tasas de Cambio"

#: ../../advanced.md:160
msgid "Cache exchange rates to reduce API calls:"
msgstr "Almacene en caché las tasas de cambio para reducir las llamadas a la API:"

#: ../../advanced.md:162
#, python-brace-format
msgid ""
"from cryptobot import CryptoBotClient\n"
"from datetime import datetime, timedelta\n"
"import threading\n"
"\n"
"class CachedRatesClient:\n"
"    def __init__(self, api_token, cache_ttl_seconds=300):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.cache_ttl = timedelta(seconds=cache_ttl_seconds)\n"
"        self._rates_cache = None\n"
"        self._cache_timestamp = None\n"
"        self._cache_lock = threading.Lock()\n"
"\n"
"    def get_exchange_rates(self, force_refresh=False):\n"
"        \"\"\"Get exchange rates with caching\"\"\"\n"
"        with self._cache_lock:\n"
"            now = datetime.now()\n"
"\n"
"            # Check if cache is valid\n"
"            if (not force_refresh and\n"
"                self._rates_cache is not None and\n"
"                self._cache_timestamp is not None and\n"
"                now - self._cache_timestamp < self.cache_ttl):\n"
"                return self._rates_cache\n"
"\n"
"            # Fetch fresh rates\n"
"            self._rates_cache = self.client.get_exchange_rates()\n"
"            self._cache_timestamp = now\n"
"            return self._rates_cache\n"
"\n"
"    def convert_amount(self, amount, from_asset, to_currency):\n"
"        \"\"\"Convert amount using cached rates\"\"\"\n"
"        rates = self.get_exchange_rates()\n"
"\n"
"        for rate in rates:\n"
"            if rate.source.name == from_asset and rate.target == "
"to_currency:\n"
"                return float(amount) * float(rate.rate)\n"
"\n"
"        return None\n"
"\n"
"# Usage\n"
"cached_client = CachedRatesClient(\"YOUR_API_TOKEN\", "
"cache_ttl_seconds=300)\n"
"\n"
"# First call fetches from API\n"
"rates1 = cached_client.get_exchange_rates()\n"
"\n"
"# Subsequent calls use cache (within TTL)\n"
"rates2 = cached_client.get_exchange_rates()\n"
"\n"
"# Convert amounts using cached rates\n"
"usd_amount = cached_client.convert_amount(1.0, \"BTC\", \"USD\")\n"
"print(f\"1 BTC = ${usd_amount} USD\")\n"
msgstr ""
"from cryptobot import CryptoBotClient\n"
"from datetime import datetime, timedelta\n"
"import threading\n"
"\n"
"class CachedRatesClient:\n"
"    def __init__(self, api_token, cache_ttl_seconds=300):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.cache_ttl = timedelta(seconds=cache_ttl_seconds)\n"
"        self._rates_cache = None\n"
"        self._cache_timestamp = None\n"
"        self._cache_lock = threading.Lock()\n"
"\n"
"    def get_exchange_rates(self, force_refresh=False):\n"
"        \"\"\"Get exchange rates with caching\"\"\"\n"
"        with self._cache_lock:\n"
"            now = datetime.now()\n"
"\n"
"            # Check if cache is valid\n"
"            if (not force_refresh and\n"
"                self._rates_cache is not None and\n"
"                self._cache_timestamp is not None and\n"
"                now - self._cache_timestamp < self.cache_ttl):\n"
"                return self._rates_cache\n"
"\n"
"            # Fetch fresh rates\n"
"            self._rates_cache = self.client.get_exchange_rates()\n"
"            self._cache_timestamp = now\n"
"            return self._rates_cache\n"
"\n"
"    def convert_amount(self, amount, from_asset, to_currency):\n"
"        \"\"\"Convert amount using cached rates\"\"\"\n"
"        rates = self.get_exchange_rates()\n"
"\n"
"        for rate in rates:\n"
"            if rate.source.name == from_asset and rate.target == "
"to_currency:\n"
"                return float(amount) * float(rate.rate)\n"
"\n"
"        return None\n"
"\n"
"# Usage\n"
"cached_client = CachedRatesClient(\"YOUR_API_TOKEN\", "
"cache_ttl_seconds=300)\n"
"\n"
"# First call fetches from API\n"
"rates1 = cached_client.get_exchange_rates()\n"
"\n"
"# Subsequent calls use cache (within TTL)\n"
"rates2 = cached_client.get_exchange_rates()\n"
"\n"
"# Convert amounts using cached rates\n"
"usd_amount = cached_client.convert_amount(1.0, \"BTC\", \"USD\")\n"
"print(f\"1 BTC = ${usd_amount} USD\")\n"

#: ../../advanced.md:216
msgid "Webhook Security"
msgstr "Seguridad de Webhooks"

#: ../../advanced.md:218
msgid "Enhanced Webhook Verification"
msgstr "Verificación de Webhook Mejorada"

#: ../../advanced.md:220
msgid "Implement comprehensive webhook security:"
msgstr "Implemente una seguridad integral para los webhooks:"

#: ../../advanced.md:222
#, python-brace-format
msgid ""
"from fastapi import FastAPI, Request, HTTPException, Header\n"
"import hmac\n"
"import hashlib\n"
"import json\n"
"import time\n"
"from typing import Optional\n"
"\n"
"app = FastAPI()\n"
"\n"
"# Store processed webhook IDs to prevent replay attacks\n"
"processed_webhooks = set()\n"
"webhook_expiry_seconds = 300  # 5 minutes\n"
"\n"
"def verify_webhook_signature(\n"
"    body: bytes,\n"
"    signature: str,\n"
"    secret: str\n"
") -> bool:\n"
"    \"\"\"Verify webhook signature using HMAC-SHA256\"\"\"\n"
"    expected_signature = hmac.new(\n"
"        secret.encode(),\n"
"        body,\n"
"        hashlib.sha256\n"
"    ).hexdigest()\n"
"\n"
"    return hmac.compare_digest(signature, expected_signature)\n"
"\n"
"def check_replay_attack(webhook_id: str, timestamp: int) -> bool:\n"
"    \"\"\"Check if webhook is a replay attack\"\"\"\n"
"    now = int(time.time())\n"
"\n"
"    # Check if webhook is too old\n"
"    if now - timestamp > webhook_expiry_seconds:\n"
"        return True\n"
"\n"
"    # Check if we've already processed this webhook\n"
"    if webhook_id in processed_webhooks:\n"
"        return True\n"
"\n"
"    return False\n"
"\n"
"@app.post(\"/webhook\")\n"
"async def secure_webhook_handler(\n"
"    request: Request,\n"
"    crypto_pay_api_signature: Optional[str] = Header(None)\n"
"):\n"
"    \"\"\"Secure webhook handler with multiple security checks\"\"\"\n"
"    # Check signature header exists\n"
"    if not crypto_pay_api_signature:\n"
"        raise HTTPException(status_code=401, detail=\"Missing "
"signature\")\n"
"\n"
"    # Read body\n"
"    body = await request.body()\n"
"\n"
"    # Verify signature\n"
"    webhook_secret = \"YOUR_WEBHOOK_SECRET\"\n"
"    if not verify_webhook_signature(body, crypto_pay_api_signature, "
"webhook_secret):\n"
"        raise HTTPException(status_code=401, detail=\"Invalid "
"signature\")\n"
"\n"
"    # Parse payload\n"
"    try:\n"
"        payload = json.loads(body)\n"
"    except json.JSONDecodeError:\n"
"        raise HTTPException(status_code=400, detail=\"Invalid JSON\")\n"
"\n"
"    # Extract webhook metadata\n"
"    webhook_id = payload.get(\"update_id\")\n"
"    webhook_type = payload.get(\"update_type\")\n"
"\n"
"    # Check for replay attack\n"
"    timestamp = payload.get(\"request_date\", int(time.time()))\n"
"    if check_replay_attack(str(webhook_id), timestamp):\n"
"        raise HTTPException(status_code=400, detail=\"Replay attack "
"detected\")\n"
"\n"
"    # Mark webhook as processed\n"
"    processed_webhooks.add(str(webhook_id))\n"
"\n"
"    # Process webhook based on type\n"
"    if webhook_type == \"invoice_paid\":\n"
"        invoice_data = payload.get(\"payload\")\n"
"        # Process paid invoice\n"
"        process_paid_invoice(invoice_data)\n"
"\n"
"    return {\"status\": \"ok\"}\n"
"\n"
"def process_paid_invoice(invoice_data):\n"
"    \"\"\"Process a paid invoice\"\"\"\n"
"    invoice_id = invoice_data.get(\"invoice_id\")\n"
"    amount = invoice_data.get(\"amount\")\n"
"    asset = invoice_data.get(\"asset\")\n"
"\n"
"    print(f\"Invoice {invoice_id} paid: {amount} {asset}\")\n"
"    # Add your business logic here\n"
msgstr ""
"from fastapi import FastAPI, Request, HTTPException, Header\n"
"import hmac\n"
"import hashlib\n"
"import json\n"
"import time\n"
"from typing import Optional\n"
"\n"
"app = FastAPI()\n"
"\n"
"# Store processed webhook IDs to prevent replay attacks\n"
"processed_webhooks = set()\n"
"webhook_expiry_seconds = 300  # 5 minutes\n"
"\n"
"def verify_webhook_signature(\n"
"    body: bytes,\n"
"    signature: str,\n"
"    secret: str\n"
") -> bool:\n"
"    \"\"\"Verify webhook signature using HMAC-SHA256\"\"\"\n"
"    expected_signature = hmac.new(\n"
"        secret.encode(),\n"
"        body,\n"
"        hashlib.sha256\n"
"    ).hexdigest()\n"
"\n"
"    return hmac.compare_digest(signature, expected_signature)\n"
"\n"
"def check_replay_attack(webhook_id: str, timestamp: int) -> bool:\n"
"    \"\"\"Check if webhook is a replay attack\"\"\"\n"
"    now = int(time.time())\n"
"\n"
"    # Check if webhook is too old\n"
"    if now - timestamp > webhook_expiry_seconds:\n"
"        return True\n"
"\n"
"    # Check if we've already processed this webhook\n"
"    if webhook_id in processed_webhooks:\n"
"        return True\n"
"\n"
"    return False\n"
"\n"
"@app.post(\"/webhook\")\n"
"async def secure_webhook_handler(\n"
"    request: Request,\n"
"    crypto_pay_api_signature: Optional[str] = Header(None)\n"
"):\n"
"    \"\"\"Secure webhook handler with multiple security checks\"\"\"\n"
"    # Check signature header exists\n"
"    if not crypto_pay_api_signature:\n"
"        raise HTTPException(status_code=401, detail=\"Missing "
"signature\")\n"
"\n"
"    # Read body\n"
"    body = await request.body()\n"
"\n"
"    # Verify signature\n"
"    webhook_secret = \"YOUR_WEBHOOK_SECRET\"\n"
"    if not verify_webhook_signature(body, crypto_pay_api_signature, "
"webhook_secret):\n"
"        raise HTTPException(status_code=401, detail=\"Invalid "
"signature\")\n"
"\n"
"    # Parse payload\n"
"    try:\n"
"        payload = json.loads(body)\n"
"    except json.JSONDecodeError:\n"
"        raise HTTPException(status_code=400, detail=\"Invalid JSON\")\n"
"\n"
"    # Extract webhook metadata\n"
"    webhook_id = payload.get(\"update_id\")\n"
"    webhook_type = payload.get(\"update_type\")\n"
"\n"
"    # Check for replay attack\n"
"    timestamp = payload.get(\"request_date\", int(time.time()))\n"
"    if check_replay_attack(str(webhook_id), timestamp):\n"
"        raise HTTPException(status_code=400, detail=\"Replay attack "
"detected\")\n"
"\n"
"    # Mark webhook as processed\n"
"    processed_webhooks.add(str(webhook_id))\n"
"\n"
"    # Process webhook based on type\n"
"    if webhook_type == \"invoice_paid\":\n"
"        invoice_data = payload.get(\"payload\")\n"
"        # Process paid invoice\n"
"        process_paid_invoice(invoice_data)\n"
"\n"
"    return {\"status\": \"ok\"}\n"
"\n"
"def process_paid_invoice(invoice_data):\n"
"    \"\"\"Process a paid invoice\"\"\"\n"
"    invoice_id = invoice_data.get(\"invoice_id\")\n"
"    amount = invoice_data.get(\"amount\")\n"
"    asset = invoice_data.get(\"asset\")\n"
"\n"
"    print(f\"Invoice {invoice_id} paid: {amount} {asset}\")\n"
"    # Add your business logic here\n"

#: ../../advanced.md:318
msgid "Webhook Queue Processing"
msgstr "Procesamiento de Webhooks en Cola"

#: ../../advanced.md:320
msgid "Use a queue for asynchronous webhook processing:"
msgstr "Use una cola para procesar webhooks de forma asíncrona:"

#: ../../advanced.md:322
#, python-brace-format
msgid ""
"from fastapi import FastAPI, Request, BackgroundTasks\n"
"import asyncio\n"
"from queue import Queue\n"
"import threading\n"
"import hmac\n"
"import hashlib\n"
"\n"
"app = FastAPI()\n"
"webhook_queue = Queue()\n"
"\n"
"def verify_signature(body: bytes, signature: str, secret: str) -> bool:\n"
"    \"\"\"Verify webhook signature\"\"\"\n"
"    expected = hmac.new(secret.encode(), body, "
"hashlib.sha256).hexdigest()\n"
"    return hmac.compare_digest(signature, expected)\n"
"\n"
"def webhook_processor():\n"
"    \"\"\"Background worker to process webhooks\"\"\"\n"
"    while True:\n"
"        try:\n"
"            webhook_data = webhook_queue.get(timeout=1)\n"
"            # Process webhook\n"
"            process_webhook(webhook_data)\n"
"            webhook_queue.task_done()\n"
"        except:\n"
"            pass\n"
"\n"
"def process_webhook(data):\n"
"    \"\"\"Process webhook data\"\"\"\n"
"    # Add your processing logic here\n"
"    print(f\"Processing webhook: {data}\")\n"
"\n"
"# Start background worker\n"
"worker_thread = threading.Thread(target=webhook_processor, daemon=True)\n"
"worker_thread.start()\n"
"\n"
"@app.post(\"/webhook\")\n"
"async def webhook_handler(\n"
"    request: Request,\n"
"    background_tasks: BackgroundTasks\n"
"):\n"
"    \"\"\"Webhook handler with queue processing\"\"\"\n"
"    signature = request.headers.get(\"crypto-pay-api-signature\")\n"
"    body = await request.body()\n"
"\n"
"    # Quick signature verification\n"
"    if not verify_signature(body, signature, \"YOUR_SECRET\"):\n"
"        return {\"error\": \"Invalid signature\"}, 401\n"
"\n"
"    # Parse payload\n"
"    import json\n"
"    payload = json.loads(body)\n"
"\n"
"    # Add to queue for async processing\n"
"    webhook_queue.put(payload)\n"
"\n"
"    # Return immediately\n"
"    return {\"status\": \"queued\"}\n"
msgstr ""
"from fastapi import FastAPI, Request, BackgroundTasks\n"
"import asyncio\n"
"from queue import Queue\n"
"import threading\n"
"import hmac\n"
"import hashlib\n"
"\n"
"app = FastAPI()\n"
"webhook_queue = Queue()\n"
"\n"
"def verify_signature(body: bytes, signature: str, secret: str) -> bool:\n"
"    \"\"\"Verify webhook signature\"\"\"\n"
"    expected = hmac.new(secret.encode(), body, "
"hashlib.sha256).hexdigest()\n"
"    return hmac.compare_digest(signature, expected)\n"
"\n"
"def webhook_processor():\n"
"    \"\"\"Background worker to process webhooks\"\"\"\n"
"    while True:\n"
"        try:\n"
"            webhook_data = webhook_queue.get(timeout=1)\n"
"            # Process webhook\n"
"            process_webhook(webhook_data)\n"
"            webhook_queue.task_done()\n"
"        except:\n"
"            pass\n"
"\n"
"def process_webhook(data):\n"
"    \"\"\"Process webhook data\"\"\"\n"
"    # Add your processing logic here\n"
"    print(f\"Processing webhook: {data}\")\n"
"\n"
"# Start background worker\n"
"worker_thread = threading.Thread(target=webhook_processor, daemon=True)\n"
"worker_thread.start()\n"
"\n"
"@app.post(\"/webhook\")\n"
"async def webhook_handler(\n"
"    request: Request,\n"
"    background_tasks: BackgroundTasks\n"
"):\n"
"    \"\"\"Webhook handler with queue processing\"\"\"\n"
"    signature = request.headers.get(\"crypto-pay-api-signature\")\n"
"    body = await request.body()\n"
"\n"
"    # Quick signature verification\n"
"    if not verify_signature(body, signature, \"YOUR_SECRET\"):\n"
"        return {\"error\": \"Invalid signature\"}, 401\n"
"\n"
"    # Parse payload\n"
"    import json\n"
"    payload = json.loads(body)\n"
"\n"
"    # Add to queue for async processing\n"
"    webhook_queue.put(payload)\n"
"\n"
"    # Return immediately\n"
"    return {\"status\": \"queued\"}\n"

#: ../../advanced.md:382
msgid "Database Integration"
msgstr "Integración con Base de Datos"

#: ../../advanced.md:384
msgid "Invoice Tracking with SQLAlchemy"
msgstr "Seguimiento de Facturas con SQLAlchemy"

#: ../../advanced.md:386
msgid "Track invoices in a database:"
msgstr "Registre las facturas en una base de datos:"

#: ../../advanced.md:388
msgid ""
"from sqlalchemy import create_engine, Column, Integer, String, Float, "
"DateTime\n"
"from sqlalchemy.ext.declarative import declarative_base\n"
"from sqlalchemy.orm import sessionmaker\n"
"from datetime import datetime\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset, Status\n"
"\n"
"Base = declarative_base()\n"
"\n"
"class InvoiceRecord(Base):\n"
"    __tablename__ = \"invoices\"\n"
"\n"
"    id = Column(Integer, primary_key=True)\n"
"    invoice_id = Column(Integer, unique=True, index=True)\n"
"    user_id = Column(Integer, index=True)\n"
"    asset = Column(String)\n"
"    amount = Column(Float)\n"
"    description = Column(String)\n"
"    status = Column(String)\n"
"    created_at = Column(DateTime, default=datetime.utcnow)\n"
"    paid_at = Column(DateTime, nullable=True)\n"
"    payload = Column(String, nullable=True)\n"
"\n"
"class InvoiceManager:\n"
"    def __init__(self, api_token, database_url):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.engine = create_engine(database_url)\n"
"        Base.metadata.create_all(self.engine)\n"
"        self.Session = sessionmaker(bind=self.engine)\n"
"\n"
"    def create_and_track_invoice(self, user_id, asset, amount, "
"description, payload=None):\n"
"        \"\"\"Create invoice and save to database\"\"\"\n"
"        # Create invoice via API\n"
"        invoice = self.client.create_invoice(\n"
"            asset=asset,\n"
"            amount=amount,\n"
"            description=description,\n"
"            payload=payload\n"
"        )\n"
"\n"
"        # Save to database\n"
"        session = self.Session()\n"
"        try:\n"
"            record = InvoiceRecord(\n"
"                invoice_id=invoice.invoice_id,\n"
"                user_id=user_id,\n"
"                asset=asset.name,\n"
"                amount=amount,\n"
"                description=description,\n"
"                status=invoice.status.name,\n"
"                payload=payload\n"
"            )\n"
"            session.add(record)\n"
"            session.commit()\n"
"        finally:\n"
"            session.close()\n"
"\n"
"        return invoice\n"
"\n"
"    def update_invoice_status(self, invoice_id):\n"
"        \"\"\"Update invoice status from API\"\"\"\n"
"        # Fetch from API\n"
"        invoices = self.client.get_invoices(invoice_ids=str(invoice_id))\n"
"        if not invoices:\n"
"            return None\n"
"\n"
"        invoice = invoices[0]\n"
"\n"
"        # Update database\n"
"        session = self.Session()\n"
"        try:\n"
"            record = session.query(InvoiceRecord).filter_by(\n"
"                invoice_id=invoice_id\n"
"            ).first()\n"
"\n"
"            if record:\n"
"                record.status = invoice.status.name\n"
"                if invoice.status == Status.paid:\n"
"                    record.paid_at = datetime.utcnow()\n"
"                session.commit()\n"
"                return record\n"
"        finally:\n"
"            session.close()\n"
"\n"
"    def get_user_invoices(self, user_id):\n"
"        \"\"\"Get all invoices for a user\"\"\"\n"
"        session = self.Session()\n"
"        try:\n"
"            return session.query(InvoiceRecord).filter_by(\n"
"                user_id=user_id\n"
"            ).all()\n"
"        finally:\n"
"            session.close()\n"
"\n"
"# Usage\n"
"manager = InvoiceManager(\n"
"    \"YOUR_API_TOKEN\",\n"
"    \"sqlite:///invoices.db\"\n"
")\n"
"\n"
"# Create and track invoice\n"
"invoice = manager.create_and_track_invoice(\n"
"    user_id=12345,\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Test invoice\",\n"
"    payload=\"ORDER_123\"\n"
")\n"
"\n"
"# Update status\n"
"manager.update_invoice_status(invoice.invoice_id)\n"
"\n"
"# Get user's invoices\n"
"user_invoices = manager.get_user_invoices(12345)\n"
msgstr ""
"from sqlalchemy import create_engine, Column, Integer, String, Float, "
"DateTime\n"
"from sqlalchemy.ext.declarative import declarative_base\n"
"from sqlalchemy.orm import sessionmaker\n"
"from datetime import datetime\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset, Status\n"
"\n"
"Base = declarative_base()\n"
"\n"
"class InvoiceRecord(Base):\n"
"    __tablename__ = \"invoices\"\n"
"\n"
"    id = Column(Integer, primary_key=True)\n"
"    invoice_id = Column(Integer, unique=True, index=True)\n"
"    user_id = Column(Integer, index=True)\n"
"    asset = Column(String)\n"
"    amount = Column(Float)\n"
"    description = Column(String)\n"
"    status = Column(String)\n"
"    created_at = Column(DateTime, default=datetime.utcnow)\n"
"    paid_at = Column(DateTime, nullable=True)\n"
"    payload = Column(String, nullable=True)\n"
"\n"
"class InvoiceManager:\n"
"    def __init__(self, api_token, database_url):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.engine = create_engine(database_url)\n"
"        Base.metadata.create_all(self.engine)\n"
"        self.Session = sessionmaker(bind=self.engine)\n"
"\n"
"    def create_and_track_invoice(self, user_id, asset, amount, "
"description, payload=None):\n"
"        \"\"\"Create invoice and save to database\"\"\"\n"
"        # Create invoice via API\n"
"        invoice = self.client.create_invoice(\n"
"            asset=asset,\n"
"            amount=amount,\n"
"            description=description,\n"
"            payload=payload\n"
"        )\n"
"\n"
"        # Save to database\n"
"        session = self.Session()\n"
"        try:\n"
"            record = InvoiceRecord(\n"
"                invoice_id=invoice.invoice_id,\n"
"                user_id=user_id,\n"
"                asset=asset.name,\n"
"                amount=amount,\n"
"                description=description,\n"
"                status=invoice.status.name,\n"
"                payload=payload\n"
"            )\n"
"            session.add(record)\n"
"            session.commit()\n"
"        finally:\n"
"            session.close()\n"
"\n"
"        return invoice\n"
"\n"
"    def update_invoice_status(self, invoice_id):\n"
"        \"\"\"Update invoice status from API\"\"\"\n"
"        # Fetch from API\n"
"        invoices = self.client.get_invoices(invoice_ids=str(invoice_id))\n"
"        if not invoices:\n"
"            return None\n"
"\n"
"        invoice = invoices[0]\n"
"\n"
"        # Update database\n"
"        session = self.Session()\n"
"        try:\n"
"            record = session.query(InvoiceRecord).filter_by(\n"
"                invoice_id=invoice_id\n"
"            ).first()\n"
"\n"
"            if record:\n"
"                record.status = invoice.status.name\n"
"                if invoice.status == Status.paid:\n"
"                    record.paid_at = datetime.utcnow()\n"
"                session.commit()\n"
"                return record\n"
"        finally:\n"
"            session.close()\n"
"\n"
"    def get_user_invoices(self, user_id):\n"
"        \"\"\"Get all invoices for a user\"\"\"\n"
"        session = self.Session()\n"
"        try:\n"
"            return session.query(InvoiceRecord).filter_by(\n"
"                user_id=user_id\n"
"            ).all()\n"
"        finally:\n"
"            session.close()\n"
"\n"
"# Usage\n"
"manager = InvoiceManager(\n"
"    \"YOUR_API_TOKEN\",\n"
"    \"sqlite:///invoices.db\"\n"
")\n"
"\n"
"# Create and track invoice\n"
"invoice = manager.create_and_track_invoice(\n"
"    user_id=12345,\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Test invoice\",\n"
"    payload=\"ORDER_123\"\n"
")\n"
"\n"
"# Update status\n"
"manager.update_invoice_status(invoice.invoice_id)\n"
"\n"
"# Get user's invoices\n"
"user_invoices = manager.get_user_invoices(12345)\n"

#: ../../advanced.md:505
msgid "Logging and Monitoring"
msgstr "Registro y Monitoreo"

#: ../../advanced.md:507
msgid "Comprehensive Logging"
msgstr "Registro Integral"

#: ../../advanced.md:509
msgid "Implement detailed logging for production:"
msgstr "Implemente registros detallados para producción:"

#: ../../advanced.md:511
#, python-brace-format, python-format
msgid ""
"import logging\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.errors import CryptoBotError\n"
"from cryptobot.models import Asset\n"
"\n"
"# Configure logging\n"
"logging.basicConfig(\n"
"    level=logging.INFO,\n"
"    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n"
"    handlers=[\n"
"        logging.FileHandler('cryptobot.log'),\n"
"        logging.StreamHandler()\n"
"    ]\n"
")\n"
"\n"
"class LoggedCryptoBotClient:\n"
"    def __init__(self, api_token, is_mainnet=True):\n"
"        self.client = CryptoBotClient(api_token, is_mainnet)\n"
"        self.logger = logging.getLogger('CryptoBot')\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Create invoice with logging\"\"\"\n"
"        self.logger.info(f\"Creating invoice: {kwargs}\")\n"
"        try:\n"
"            invoice = self.client.create_invoice(**kwargs)\n"
"            self.logger.info(\n"
"                f\"Invoice created successfully: {invoice.invoice_id}\"\n"
"            )\n"
"            return invoice\n"
"        except CryptoBotError as e:\n"
"            self.logger.error(\n"
"                f\"Failed to create invoice: {e.code} - {e.name} - "
"{e.description}\"\n"
"            )\n"
"            raise\n"
"\n"
"    def transfer(self, **kwargs):\n"
"        \"\"\"Transfer with logging\"\"\"\n"
"        self.logger.info(f\"Initiating transfer: {kwargs}\")\n"
"        try:\n"
"            transfer = self.client.transfer(**kwargs)\n"
"            self.logger.info(\n"
"                f\"Transfer completed: {transfer.transfer_id}\"\n"
"            )\n"
"            return transfer\n"
"        except CryptoBotError as e:\n"
"            self.logger.error(\n"
"                f\"Transfer failed: {e.code} - {e.name} - "
"{e.description}\"\n"
"            )\n"
"            raise\n"
"\n"
"# Usage\n"
"logged_client = LoggedCryptoBotClient(\"YOUR_API_TOKEN\")\n"
"invoice = logged_client.create_invoice(\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Logged invoice\"\n"
")\n"
msgstr ""
"import logging\n"
"from cryptobot import CryptoBotClient\n"
"from cryptobot.errors import CryptoBotError\n"
"from cryptobot.models import Asset\n"
"\n"
"# Configure logging\n"
"logging.basicConfig(\n"
"    level=logging.INFO,\n"
"    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n"
"    handlers=[\n"
"        logging.FileHandler('cryptobot.log'),\n"
"        logging.StreamHandler()\n"
"    ]\n"
")\n"
"\n"
"class LoggedCryptoBotClient:\n"
"    def __init__(self, api_token, is_mainnet=True):\n"
"        self.client = CryptoBotClient(api_token, is_mainnet)\n"
"        self.logger = logging.getLogger('CryptoBot')\n"
"\n"
"    def create_invoice(self, **kwargs):\n"
"        \"\"\"Create invoice with logging\"\"\"\n"
"        self.logger.info(f\"Creating invoice: {kwargs}\")\n"
"        try:\n"
"            invoice = self.client.create_invoice(**kwargs)\n"
"            self.logger.info(\n"
"                f\"Invoice created successfully: {invoice.invoice_id}\"\n"
"            )\n"
"            return invoice\n"
"        except CryptoBotError as e:\n"
"            self.logger.error(\n"
"                f\"Failed to create invoice: {e.code} - {e.name} - "
"{e.description}\"\n"
"            )\n"
"            raise\n"
"\n"
"    def transfer(self, **kwargs):\n"
"        \"\"\"Transfer with logging\"\"\"\n"
"        self.logger.info(f\"Initiating transfer: {kwargs}\")\n"
"        try:\n"
"            transfer = self.client.transfer(**kwargs)\n"
"            self.logger.info(\n"
"                f\"Transfer completed: {transfer.transfer_id}\"\n"
"            )\n"
"            return transfer\n"
"        except CryptoBotError as e:\n"
"            self.logger.error(\n"
"                f\"Transfer failed: {e.code} - {e.name} - "
"{e.description}\"\n"
"            )\n"
"            raise\n"
"\n"
"# Usage\n"
"logged_client = LoggedCryptoBotClient(\"YOUR_API_TOKEN\")\n"
"invoice = logged_client.create_invoice(\n"
"    asset=Asset.USDT,\n"
"    amount=10.0,\n"
"    description=\"Logged invoice\"\n"
")\n"

#: ../../advanced.md:571
msgid "Testing Strategies"
msgstr "Estrategias de Pruebas"

#: ../../advanced.md:573
msgid "Mock Client for Unit Tests"
msgstr "Cliente Simulado para Pruebas Unitarias"

#: ../../advanced.md:575
msgid "Create a mock client for testing:"
msgstr "Cree un cliente simulado para las pruebas:"

#: ../../advanced.md:577
msgid ""
"from unittest.mock import Mock, patch\n"
"from cryptobot.models import Invoice, Asset, Status, Balance\n"
"import pytest\n"
"\n"
"class MockCryptoBotClient:\n"
"    \"\"\"Mock client for testing\"\"\"\n"
"    def __init__(self, api_token, is_mainnet=True, timeout=5.0):\n"
"        self.api_token = api_token\n"
"        self.invoices = []\n"
"        self.transfers = []\n"
"\n"
"    def create_invoice(self, asset, amount, **kwargs):\n"
"        \"\"\"Mock invoice creation\"\"\"\n"
"        invoice = Invoice(\n"
"            invoice_id=len(self.invoices) + 1,\n"
"            status=Status.active,\n"
"            hash=\"mock_hash\",\n"
"            amount=str(amount),\n"
"            asset=asset,\n"
"            bot_invoice_url=\"https://t.me/CryptoBot?start=mock\",\n"
"            **kwargs\n"
"        )\n"
"        self.invoices.append(invoice)\n"
"        return invoice\n"
"\n"
"    def get_invoices(self, **kwargs):\n"
"        \"\"\"Mock get invoices\"\"\"\n"
"        return self.invoices\n"
"\n"
"    def get_balances(self):\n"
"        \"\"\"Mock get balances\"\"\"\n"
"        return [\n"
"            Balance(currency_code=\"USDT\", available=\"1000.0\", "
"onhold=\"0.0\"),\n"
"            Balance(currency_code=\"BTC\", available=\"0.5\", "
"onhold=\"0.0\")\n"
"        ]\n"
"\n"
"# Usage in tests\n"
"def test_invoice_creation():\n"
"    client = MockCryptoBotClient(\"test_token\")\n"
"\n"
"    invoice = client.create_invoice(\n"
"        asset=Asset.USDT,\n"
"        amount=10.0,\n"
"        description=\"Test\"\n"
"    )\n"
"\n"
"    assert invoice.invoice_id == 1\n"
"    assert invoice.amount == \"10.0\"\n"
"    assert invoice.asset == Asset.USDT\n"
"\n"
"def test_get_invoices():\n"
"    client = MockCryptoBotClient(\"test_token\")\n"
"\n"
"    # Create some invoices\n"
"    client.create_invoice(Asset.USDT, 10.0, description=\"Test 1\")\n"
"    client.create_invoice(Asset.BTC, 0.001, description=\"Test 2\")\n"
"\n"
"    # Get invoices\n"
"    invoices = client.get_invoices()\n"
"\n"
"    assert len(invoices) == 2\n"
"    assert invoices[0].description == \"Test 1\"\n"
"    assert invoices[1].description == \"Test 2\"\n"
msgstr ""
"from unittest.mock import Mock, patch\n"
"from cryptobot.models import Invoice, Asset, Status, Balance\n"
"import pytest\n"
"\n"
"class MockCryptoBotClient:\n"
"    \"\"\"Mock client for testing\"\"\"\n"
"    def __init__(self, api_token, is_mainnet=True, timeout=5.0):\n"
"        self.api_token = api_token\n"
"        self.invoices = []\n"
"        self.transfers = []\n"
"\n"
"    def create_invoice(self, asset, amount, **kwargs):\n"
"        \"\"\"Mock invoice creation\"\"\"\n"
"        invoice = Invoice(\n"
"            invoice_id=len(self.invoices) + 1,\n"
"            status=Status.active,\n"
"            hash=\"mock_hash\",\n"
"            amount=str(amount),\n"
"            asset=asset,\n"
"            bot_invoice_url=\"https://t.me/CryptoBot?start=mock\",\n"
"            **kwargs\n"
"        )\n"
"        self.invoices.append(invoice)\n"
"        return invoice\n"
"\n"
"    def get_invoices(self, **kwargs):\n"
"        \"\"\"Mock get invoices\"\"\"\n"
"        return self.invoices\n"
"\n"
"    def get_balances(self):\n"
"        \"\"\"Mock get balances\"\"\"\n"
"        return [\n"
"            Balance(currency_code=\"USDT\", available=\"1000.0\", "
"onhold=\"0.0\"),\n"
"            Balance(currency_code=\"BTC\", available=\"0.5\", "
"onhold=\"0.0\")\n"
"        ]\n"
"\n"
"# Usage in tests\n"
"def test_invoice_creation():\n"
"    client = MockCryptoBotClient(\"test_token\")\n"
"\n"
"    invoice = client.create_invoice(\n"
"        asset=Asset.USDT,\n"
"        amount=10.0,\n"
"        description=\"Test\"\n"
"    )\n"
"\n"
"    assert invoice.invoice_id == 1\n"
"    assert invoice.amount == \"10.0\"\n"
"    assert invoice.asset == Asset.USDT\n"
"\n"
"def test_get_invoices():\n"
"    client = MockCryptoBotClient(\"test_token\")\n"
"\n"
"    # Create some invoices\n"
"    client.create_invoice(Asset.USDT, 10.0, description=\"Test 1\")\n"
"    client.create_invoice(Asset.BTC, 0.001, description=\"Test 2\")\n"
"\n"
"    # Get invoices\n"
"    invoices = client.get_invoices()\n"
"\n"
"    assert len(invoices) == 2\n"
"    assert invoices[0].description == \"Test 1\"\n"
"    assert invoices[1].description == \"Test 2\"\n"

#: ../../advanced.md:643
msgid "Performance Optimization"
msgstr "Optimización del Rendimiento"

#: ../../advanced.md:645
msgid "Batch Operations"
msgstr "Operaciones por Lotes"

#: ../../advanced.md:647
msgid "Process multiple invoices efficiently:"
msgstr "Procese varias facturas de forma eficiente:"

#: ../../advanced.md:649
#, python-brace-format
msgid ""
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset\n"
"from concurrent.futures import ThreadPoolExecutor, as_completed\n"
"\n"
"class BatchProcessor:\n"
"    def __init__(self, api_token, max_workers=10):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.max_workers = max_workers\n"
"\n"
"    def create_invoices_batch(self, invoice_specs):\n"
"        \"\"\"Create multiple invoices in parallel\"\"\"\n"
"        results = []\n"
"        errors = []\n"
"\n"
"        with ThreadPoolExecutor(max_workers=self.max_workers) as "
"executor:\n"
"            # Submit all tasks\n"
"            future_to_spec = {\n"
"                executor.submit(\n"
"                    self.client.create_invoice,\n"
"                    **spec\n"
"                ): spec\n"
"                for spec in invoice_specs\n"
"            }\n"
"\n"
"            # Collect results\n"
"            for future in as_completed(future_to_spec):\n"
"                spec = future_to_spec[future]\n"
"                try:\n"
"                    invoice = future.result()\n"
"                    results.append(invoice)\n"
"                except Exception as e:\n"
"                    errors.append({\"spec\": spec, \"error\": str(e)})\n"
"\n"
"        return results, errors\n"
"\n"
"# Usage\n"
"processor = BatchProcessor(\"YOUR_API_TOKEN\", max_workers=5)\n"
"\n"
"# Create 100 invoices\n"
"invoice_specs = [\n"
"    {\n"
"        \"asset\": Asset.USDT,\n"
"        \"amount\": 10.0,\n"
"        \"description\": f\"Batch invoice {i}\"\n"
"    }\n"
"    for i in range(100)\n"
"]\n"
"\n"
"invoices, errors = processor.create_invoices_batch(invoice_specs)\n"
"print(f\"Created {len(invoices)} invoices\")\n"
"print(f\"Failed {len(errors)} invoices\")\n"
msgstr ""
"from cryptobot import CryptoBotClient\n"
"from cryptobot.models import Asset\n"
"from concurrent.futures import ThreadPoolExecutor, as_completed\n"
"\n"
"class BatchProcessor:\n"
"    def __init__(self, api_token, max_workers=10):\n"
"        self.client = CryptoBotClient(api_token)\n"
"        self.max_workers = max_workers\n"
"\n"
"    def create_invoices_batch(self, invoice_specs):\n"
"        \"\"\"Create multiple invoices in parallel\"\"\"\n"
"        results = []\n"
"        errors = []\n"
"\n"
"        with ThreadPoolExecutor(max_workers=self.max_workers) as "
"executor:\n"
"            # Submit all tasks\n"
"            future_to_spec = {\n"
"                executor.submit(\n"
"                    self.client.create_invoice,\n"
"                    **spec\n"
"                ): spec\n"
"                for spec in invoice_specs\n"
"            }\n"
"\n"
"            # Collect results\n"
"            for future in as_completed(future_to_spec):\n"
"                spec = future_to_spec[future]\n"
"                try:\n"
"                    invoice = future.result()\n"
"                    results.append(invoice)\n"
"                except Exception as e:\n"
"                    errors.append({\"spec\": spec, \"error\": str(e)})\n"
"\n"
"        return results, errors\n"
"\n"
"# Usage\n"
"processor = BatchProcessor(\"YOUR_API_TOKEN\", max_workers=5)\n"
"\n"
"# Create 100 invoices\n"
"invoice_specs = [\n"
"    {\n"
"        \"asset\": Asset.USDT,\n"
"        \"amount\": 10.0,\n"
"        \"description\": f\"Batch invoice {i}\"\n"
"    }\n"
"    for i in range(100)\n"
"]\n"
"\n"
"invoices, errors = processor.create_invoices_batch(invoice_specs)\n"
"print(f\"Created {len(invoices)} invoices\")\n"
"print(f\"Failed {len(errors)} invoices\")\n"

#: ../../advanced.md:703
msgid "Environment-Specific Configuration"
msgstr "Configuración Específica por Entorno"

#: ../../advanced.md:705
msgid "Configuration Management"
msgstr "Gestión de Configuración"

#: ../../advanced.md:707
msgid "Manage different environments:"
msgstr "Administre distintos entornos:"

#: ../../advanced.md:709
msgid ""
"import os\n"
"from enum import Enum\n"
"from cryptobot import CryptoBotClient\n"
"\n"
"class Environment(Enum):\n"
"    DEVELOPMENT = \"development\"\n"
"    STAGING = \"staging\"\n"
"    PRODUCTION = \"production\"\n"
"\n"
"class Config:\n"
"    def __init__(self, env: Environment):\n"
"        self.env = env\n"
"        self._load_config()\n"
"\n"
"    def _load_config(self):\n"
"        \"\"\"Load environment-specific configuration\"\"\"\n"
"        if self.env == Environment.DEVELOPMENT:\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_DEV_TOKEN\")\n"
"            self.is_mainnet = False\n"
"            self.timeout = 60.0\n"
"            self.log_level = \"DEBUG\"\n"
"        elif self.env == Environment.STAGING:\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_STAGING_TOKEN\")\n"
"            self.is_mainnet = False\n"
"            self.timeout = 30.0\n"
"            self.log_level = \"INFO\"\n"
"        else:  # PRODUCTION\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_PROD_TOKEN\")\n"
"            self.is_mainnet = True\n"
"            self.timeout = 30.0\n"
"            self.log_level = \"WARNING\"\n"
"\n"
"    def create_client(self):\n"
"        \"\"\"Create client with environment-specific settings\"\"\"\n"
"        return CryptoBotClient(\n"
"            self.api_token,\n"
"            is_mainnet=self.is_mainnet,\n"
"            timeout=self.timeout\n"
"        )\n"
"\n"
"# Usage\n"
"env = Environment(os.getenv(\"APP_ENV\", \"development\"))\n"
"config = Config(env)\n"
"client = config.create_client()\n"
msgstr ""
"import os\n"
"from enum import Enum\n"
"from cryptobot import CryptoBotClient\n"
"\n"
"class Environment(Enum):\n"
"    DEVELOPMENT = \"development\"\n"
"    STAGING = \"staging\"\n"
"    PRODUCTION = \"production\"\n"
"\n"
"class Config:\n"
"    def __init__(self, env: Environment):\n"
"        self.env = env\n"
"        self._load_config()\n"
"\n"
"    def _load_config(self):\n"
"        \"\"\"Load environment-specific configuration\"\"\"\n"
"        if self.env == Environment.DEVELOPMENT:\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_DEV_TOKEN\")\n"
"            self.is_mainnet = False\n"
"            self.timeout = 60.0\n"
"            self.log_level = \"DEBUG\"\n"
"        elif self.env == Environment.STAGING:\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_STAGING_TOKEN\")\n"
"            self.is_mainnet = False\n"
"            self.timeout = 30.0\n"
"            self.log_level = \"INFO\"\n"
"        else:  # PRODUCTION\n"
"            self.api_token = os.getenv(\"CRYPTOBOT_PROD_TOKEN\")\n"
"            self.is_mainnet = True\n"
"            self.timeout = 30.0\n"
"            self.log_level = \"WARNING\"\n"
"\n"
"    def create_client(self):\n"
"        \"\"\"Create client with environment-specific settings\"\"\"\n"
"        return CryptoBotClient(\n"
"            self.api_token,\n"
"            is_mainnet=self.is_mainnet,\n"
"            timeout=self.timeout\n"
"        )\n"
"\n"
"# Usage\n"
"env = Environment(os.getenv(\"APP_ENV\", \"development\"))\n"
"config = Config(env)\n"
"client = config.create_client()\n"

#: ../../advanced.md:756
msgid "Next Steps"
msgstr "Próximos Pasos"

#: ../../advanced.md:758
msgid "Review the [Examples](examples) for practical implementations"
msgstr "Revise los [Ejemplos](examples) para implementaciones prácticas"

#: ../../advanced.md:759
msgid "Check the [Troubleshooting Guide](troubleshooting) for common issues"
msgstr "Consulte la [Guía de Solución de Problemas](troubleshooting) para los inconvenientes habituales"

#: ../../advanced.md:760
msgid "Explore the [API Reference](modules) for detailed documentation"
msgstr "Explore la [Referencia de la API](modules) para documentación detallada"
